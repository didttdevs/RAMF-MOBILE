package com.example.rafapp.ui.fragments

import android.graphics.Color
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.lifecycle.Lifecycle
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.TimeUnit
import android.app.DatePickerDialog
import android.app.TimePickerDialog
import android.widget.ArrayAdapter
import android.widget.Toast
import androidx.core.view.isVisible
import androidx.fragment.app.viewModels
import com.google.android.material.datepicker.MaterialDatePicker
import com.example.rafapp.utils.ChartUtils
import com.example.rafapp.utils.Constants
import com.example.rafapp.utils.NetworkUtils
import com.example.rafapp.viewmodels.GraphViewModel
import com.example.rafapp.viewmodels.GraphViewModelFactory
import com.example.rafapp.repository.WeatherRepository
import kotlinx.coroutines.flow.collectLatest
import com.example.rafapp.R
import com.example.rafapp.databinding.FragmentGraphBinding
import com.example.rafapp.models.WrapperResponse
import com.example.rafapp.network.RetrofitClient
import com.github.mikephil.charting.components.Description
import com.github.mikephil.charting.components.XAxis
import com.github.mikephil.charting.components.YAxis
import com.github.mikephil.charting.data.Entry
import com.github.mikephil.charting.data.LineData
import com.github.mikephil.charting.data.LineDataSet
import com.github.mikephil.charting.formatter.ValueFormatter
import com.github.mikephil.charting.animation.Easing
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class GraphFragment : Fragment() {

    private var _binding: FragmentGraphBinding? = null
    private val binding get() = _binding!!

    // ViewModel
    private val viewModel: GraphViewModel by viewModels {
        GraphViewModelFactory(WeatherRepository())
    }

    // Configuraciones
    private val TAG = "GraphFragment"
    private val selectedParameters = mutableSetOf<String>()
    private var dateRangeType = DateRangeType.LAST_24H
    private var customStartDate: Long? = null
    private var customEndDate: Long? = null
    
    enum class DateRangeType(val label: String, val days: Int?) {
        LAST_24H("24h", null),
        LAST_7D("7d", 7),
        LAST_30D("30d", 30),
        CUSTOM("Personalizado", null)
    }

    // Parsers para ISO con y sin milisegundos
    private val dfMs = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US).apply {
        timeZone = TimeZone.getTimeZone("UTC")
    }
    private val dfNoMs = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).apply {
        timeZone = TimeZone.getTimeZone("UTC")
    }

    private fun parseIso(iso: String?): Long? {
        if (iso.isNullOrBlank()) return null
        return try {
            dfMs.parse(iso)?.time
        } catch (_: Exception) {
            try { dfNoMs.parse(iso)?.time } catch (_: Exception) { null }
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentGraphBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupChart()
        setupControls()
        observeViewModel()
        
        // Seleccionar temperatura por defecto
        selectedParameters.add("temperatura")
        binding.chipTemperature.isChecked = true
        viewModel.updateSelectedParameters(selectedParameters)
        
        // Cargar datos iniciales
        loadInitialData()
    }
    
    private fun observeViewModel() {
        viewLifecycleOwner.lifecycleScope.launchWhenStarted {
            viewModel.uiState.collectLatest { state ->
                updateUI(state)
            }
        }
    }
    
    private fun updateUI(state: com.example.rafapp.viewmodels.GraphUiState) {
        showLoading(state.isLoading)
        
        if (state.errorMessage != null) {
            showError(true, state.errorMessage)
        } else {
            showError(false)
            state.weatherData?.let { data ->
                updateMultiParameterChart(data)
            }
        }
        
        binding.dateRangeButton.text = state.dateRangeLabel
    }
    
    private fun loadInitialData() {
        if (NetworkUtils.isNetworkAvailable(requireContext())) {
            val (from, to) = generateDateRange()
            viewModel.loadWeatherData(from, to)
        } else {
            showError(true, "Sin conexión a internet")
        }
    }
    
    private fun setupControls() {
        // Configurar date range button
        binding.dateRangeButton.setOnClickListener {
            showDateRangeDialog()
        }
        
        // Configurar retry button
        binding.retryButton?.setOnClickListener {
            viewModel.retry()
        }
        
        // Configurar export FAB
        binding.exportFab?.setOnClickListener {
            exportChart()
        }
        
        // Configurar chips para multi-selección
        setupParameterChips()
    }
    
    private fun setupParameterChips() {
        val chipToParam = mapOf(
            binding.chipTemperature to "temperatura",
            binding.chipHumidity to "humedad",
            binding.chipRadiation to "radiacion",
            binding.chipWind to "precipitacion",
            binding.chipRain to "direccionViento",
            binding.chipWindVel to "vientoVel",
            binding.chipSolardur to "solarDuration"
        )
        
        chipToParam.forEach { (chip, param) ->
            chip.setOnCheckedChangeListener { _, isChecked ->
                if (isChecked) {
                    selectedParameters.add(param)
                } else {
                    selectedParameters.remove(param)
                }
                
                if (selectedParameters.isEmpty()) {
                    // Al menos un parámetro debe estar seleccionado
                    chip.isChecked = true
                    selectedParameters.add(param)
                    Toast.makeText(requireContext(), "Debe seleccionar al menos un parámetro", Toast.LENGTH_SHORT).show()
                } else {
                    val (from, to) = generateDateRange()
                    viewModel.loadWeatherData(from, to)
                    viewModel.updateDateRangeLabel(selected.label)
                }
            }
        }
    }

    private fun setupChart() {
        binding.lineChart.apply {
            // Configuraciones básicas
            setTouchEnabled(true)
            setPinchZoom(true)
            isDragEnabled = true
            setScaleEnabled(true)
            setBackgroundColor(Color.WHITE)
            
            // Descripción
            description = Description().apply { 
                text = "" 
                textColor = Color.GRAY
                textSize = 12f
            }
            
            // Configurar eje X (tiempo)
            xAxis.apply {
                position = XAxis.XAxisPosition.BOTTOM
                textColor = Color.DARK_GRAY
                textSize = 10f
                setDrawGridLines(true)
                gridColor = Color.LTGRAY
                gridLineWidth = 0.5f
                valueFormatter = object : ValueFormatter() {
                    private val timeFormatter = SimpleDateFormat("HH:mm", Locale.getDefault())
                    override fun getFormattedValue(value: Float): String {
                        return timeFormatter.format(Date(value.toLong()))
                    }
                }
            }
            
            // Configurar eje Y izquierdo
            axisLeft.apply {
                textColor = Color.DARK_GRAY
                textSize = 10f
                setDrawGridLines(true)
                gridColor = Color.LTGRAY
                gridLineWidth = 0.5f
                isGranularityEnabled = true
            }
            
            // Deshabilitar eje Y derecho
            axisRight.isEnabled = false
            
            // Configurar leyenda
            legend.apply {
                isEnabled = true
                textColor = Color.DARK_GRAY
                textSize = 12f
                form = com.github.mikephil.charting.components.Legend.LegendForm.LINE
            }
            
            // Configuraciones adicionales
            setExtraOffsets(10f, 10f, 10f, 10f)
            setNoDataText("No hay datos disponibles")
            setNoDataTextColor(Color.GRAY)
        }
    }

    private fun fetchAndPlotMultipleData() {
        if (selectedParameters.isEmpty()) return
        
        if (!NetworkUtils.isNetworkAvailable(requireContext())) {
            showError(true, "Sin conexión a internet")
            return
        }
        
        val (from, to) = generateDateRange()
        Log.d(TAG, "Fetching data from $from to $to for parameters: $selectedParameters")
        viewModel.loadWeatherData(from, to)
    }

    private fun mapDataToEntries(data: WrapperResponse, param: String): List<Entry> {
        return data.data.mapNotNull { point ->
            try {
                val x = parseIso(point.date)?.toFloat() ?: return@mapNotNull null
                val y = when (param) {
                    "temperatura"     -> point.sensors.hcAirTemperature?.avg?.toFloat()
                    "humedad"         -> point.sensors.hcRelativeHumidity?.avg?.toFloat()
                    "radiacion"       -> point.sensors.solarRadiation?.avg?.toFloat()
                    "precipitacion"   -> point.sensors.precipitation?.sum?.toFloat()
                    "direccionViento" -> point.sensors.usonicWindDir?.last?.toFloat()
                    "vientoVel"       -> point.sensors.usonicWindSpeed?.avg?.toFloat()
                    "solarDuration"   -> point.sensors.solarRadiation?.avg?.toFloat() // Placeholder - actualizar cuando esté disponible
                    else -> null
                }
                if (y != null) Entry(x, y) else null
            } catch (e: Exception) {
                Log.e(TAG, "Error parseando punto: ${e.message}")
                null
            }
        }.sortedBy { it.x }
    }

    private fun updateMultiParameterChart(data: WrapperResponse) {
        val dataSets = mutableListOf<LineDataSet>()
        
        selectedParameters.forEach { parameter ->
            val entries = mapDataToEntries(data, parameter)
            if (entries.isNotEmpty()) {
                val dataSet = createLineDataSet(entries, getLabel(parameter), parameter)
                dataSets.add(dataSet)
            }
        }
        
        if (dataSets.isNotEmpty()) {
            val lineData = LineData(dataSets.toList())
            binding.lineChart.data = lineData
            binding.lineChart.animateX(800, Easing.EaseInOutCubic)
            binding.lineChart.invalidate()
        } else {
            binding.lineChart.clear()
            showError(true, "No hay datos disponibles para los parámetros seleccionados")
        }
    }
    
    private fun createLineDataSet(entries: List<Entry>, parameter: String): LineDataSet {
        val optimizedEntries = ChartUtils.optimizeEntries(ChartUtils.validateEntries(entries))
        return ChartUtils.createLineDataSet(optimizedEntries, parameter, selectedParameters.size > 1)
    }
    
    private fun createLineDataSetLegacy(entries: List<Entry>, label: String, parameter: String): LineDataSet {
        // Colores profesionales según el parámetro
        val parameterColors = mapOf(
            "temperatura" to Color.rgb(255, 87, 34),     // Naranja
            "humedad" to Color.rgb(33, 150, 243),        // Azul
            "radiacion" to Color.rgb(255, 193, 7),       // Amarillo
            "precipitacion" to Color.rgb(76, 175, 80),   // Verde
            "direccionViento" to Color.rgb(156, 39, 176), // Púrpura
            "vientoVel" to Color.rgb(96, 125, 139),      // Gris azulado
            "solarDuration" to Color.rgb(255, 152, 0)    // Naranja claro
        )
        
        val selectedColor = parameterColors[parameter] ?: Color.rgb(33, 150, 243)
        
        return LineDataSet(entries, label).apply {
            // Configuración de línea
            color = selectedColor
            lineWidth = if (selectedParameters.size == 1) 2.5f else 2f
            setDrawCircles(selectedParameters.size == 1)
            setDrawValues(false)
            setDrawFilled(false)
            
            // Configuración de círculos de datos
            setCircleColor(selectedColor)
            circleRadius = 2.5f
            setDrawCircleHole(true)
            circleHoleRadius = 1f
            circleHoleColor = Color.WHITE
            
            // Configuración de valores
            valueTextColor = Color.DARK_GRAY
            valueTextSize = 9f
            
            // Modo de dibujo suave
            mode = LineDataSet.Mode.CUBIC_BEZIER
            cubicIntensity = 0.15f
            
            // Configuración adicional
            isHighlightEnabled = true
            setDrawHorizontalHighlightIndicator(false)
            highlightLineWidth = 1f
            highLightColor = selectedColor
        }
    }

    private fun getLabel(param: String): String = when (param) {
        "temperatura"     -> "Temperatura del aire (°C)"
        "humedad"         -> "Humedad relativa (%)"
        "radiacion"       -> "Radiación solar (W/m²)"
        "precipitacion"   -> "Precipitación (mm)"
        "direccionViento" -> "Dirección del viento (°)"
        "vientoVel"       -> "Velocidad del viento (m/s)"
        "solarDuration"   -> "Duración de la luz solar (horas)"
        else -> param
    }

    private fun generateDateRange(): Pair<String, String> {
        val calendar = Calendar.getInstance()
        val isoFormatter = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US).apply {
            timeZone = TimeZone.getTimeZone("UTC")
        }
        
        val endDate: Date
        val startDate: Date
        
        when (dateRangeType) {
            DateRangeType.CUSTOM -> {
                if (customStartDate != null && customEndDate != null) {
                    startDate = Date(customStartDate!!)
                    endDate = Date(customEndDate!!)
                } else {
                    // Fallback a 24h si no hay fechas personalizadas
                    endDate = calendar.time
                    calendar.add(Calendar.DAY_OF_YEAR, -1)
                    startDate = calendar.time
                }
            }
            DateRangeType.LAST_24H -> {
                endDate = calendar.time
                calendar.add(Calendar.DAY_OF_YEAR, -1)
                startDate = calendar.time
            }
            else -> {
                endDate = calendar.time
                calendar.add(Calendar.DAY_OF_YEAR, -(dateRangeType.days ?: 1))
                startDate = calendar.time
            }
        }
        
        val from = isoFormatter.format(startDate)
        val to = isoFormatter.format(endDate)
        
        return Pair(from, to)
    }
    
    private fun showDateRangeDialog() {
        val options = DateRangeType.values().map { it.label }.toTypedArray()
        val currentIndex = DateRangeType.values().indexOf(dateRangeType)
        
        android.app.AlertDialog.Builder(requireContext())
            .setTitle("Seleccionar rango de fechas")
            .setSingleChoiceItems(options, currentIndex) { dialog, which ->
                val selected = DateRangeType.values()[which]
                dateRangeType = selected
                
                if (selected == DateRangeType.CUSTOM) {
                    dialog.dismiss()
                    showCustomDatePicker()
                } else {
                    binding.dateRangeButton.text = selected.label
                    dialog.dismiss()
                    fetchAndPlotMultipleData()
                }
            }
            .setNegativeButton("Cancelar", null)
            .show()
    }
    
    private fun showCustomDatePicker() {
        val dateRangePicker = MaterialDatePicker.Builder.dateRangePicker()
            .setTitleText("Seleccionar rango de fechas")
            .build()
            
        dateRangePicker.addOnPositiveButtonClickListener { selection ->
            customStartDate = selection.first
            customEndDate = selection.second
            
            val dateFormat = SimpleDateFormat("dd/MM", Locale.getDefault())
            val startStr = dateFormat.format(Date(selection.first))
            val endStr = dateFormat.format(Date(selection.second))
            
            val label = "$startStr - $endStr"
            viewModel.updateDateRangeLabel(label)
            val (from, to) = generateDateRange()
            viewModel.loadWeatherData(from, to)
        }
        
        dateRangePicker.show(parentFragmentManager, "date_range_picker")
    }
    
    private fun showLoading(show: Boolean) {
        binding.loadingIndicator?.isVisible = show
        binding.lineChart.isVisible = !show
    }
    
    private fun showError(show: Boolean, message: String = "Error al cargar datos") {
        binding.errorLayout?.isVisible = show
        binding.errorText?.text = message
        binding.lineChart.isVisible = !show
    }
    
    private fun exportChart() {
        try {
            val bitmap = binding.lineChart.chartBitmap
            // Aquí implementar la lógica de export
            Toast.makeText(requireContext(), "Función de exportación en desarrollo", Toast.LENGTH_SHORT).show()
        } catch (e: Exception) {
            Toast.makeText(requireContext(), "Error al exportar: ${e.localizedMessage}", Toast.LENGTH_SHORT).show()
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
